Microservices and Distributed Systems
    https://app.amigoscode.com/p/microservices

    https://spring.io/cloud

    you can create a banner for your spring app here:
        https://devops.datenkollektiv.de/banner.txt/index.html

To start docker:
     docker compose up -d      (-d for detached)


1. Generally, ideally, each microservice has its own database. Since we are in developing mode,
   and our laptop resources are limited, I will use the same container, with multiple DBs
   instead of having one DB per container.
   https://stackoverflow.com/questions/57421950/why-does-each-microservice-get-its-own-database

2. Since we use lombok, in each bean, like service, controller etc, if we annotate it with
    @AllArgsConstructor, then a constructor will be generated behind the scenes with all fields.
    And by having this, spring will know to search for those fields, so tha they will be injected.
    If we wouldn't use the annotation, we could manually create the constructors, or use
    @Autowired.

3. @Slf4j is a lombok annotation that adds a logger field to your class

4. why saveAndFlush is needed in some scenarios like the one used in CustomerService:
    https://www.baeldung.com/spring-data-jpa-save-saveandflush

5. http://localhost:8761/
    to see the webconsole of eureka server ... this is of course after running the EurekaServerApplication

6. Eureka version 4.0.0 onwards, which is being used in Spring Cloud 2022.0.0, you do not need to explicitly register
   using the annotation @EnableEurekaClient It automatically gets registered as client if
   spring-cloud-starter-netflix-eureka-client is on the class path. As per the - documentation
        By having spring-cloud-starter-netflix-eureka-client on the classpath, your application
        automatically registers with the Eureka Server. Configuration is required to locate the Eureka server

7. "http://FRAUD/api/v1/fraud-check/{customerId}"
    Means that eureka must be running...if you open console (see point 5) you will see there that application
    name FRAUD has an address corresponding to it, which will be used instead of FRAUD

    // one way of calling the fraud microservice
            FraudCheckResponse fraudCheckResponse = restTemplate.getForObject(
                    "http://FRAUD:8081/api/v1/fraud-check/{customerId}",
                    FraudCheckResponse.class,
                    customer.getId()
                    );

8. @LoadBalanced tells spring that the request being made can go to any of the registered eureka apps
    (for example the one from CustomerConfig, when used with
    "http://FRAUD:8081/api/v1/fraud-check/{customerId}") will go to any FRAUD app

9. Concerning the @FeignClient annotation
    https://docs.spring.io/spring-cloud-openfeign/reference/spring-cloud-openfeign.html

    "In the @FeignClient annotation the String value ("stores" above) is an arbitrary client name,
    which is used to create a Spring Cloud LoadBalancer client. You can also specify a URL using the
    url attribute (absolute value or just a hostname). The name of the bean in the application context is the fully
    qualified name of the interface.
  !!!    The load-balancer client above will want to discover the physical addresses for the "stores" service. If your
    application is a Eureka client then it will resolve the service in the Eureka service registry.
        Dan: this last sentence it why we can just specify "FRAUD" in the annotation

10. Concerning tracing ...sleuth (which is used in the lessons) is discontinued for this version of spring boot.
    Replacing it is micrometer..
    Used the below link to understand how to do things mentioned in tutorial with micrometer
    https://openvalue.blog/posts/2022/12/16/tracing-in-spring-boot-2-and-3/

    !!! TODO I could not make it work :( ...maybe have a look over the SpringBootObservability, and use
    actuator and micrometer to get info in zipkin..

11. Concerning the LoadBalancer (API Gteway)...normally you would use the load balancer offered by Google,
    AWS etc...you will not create/configure one on your own machine...

12. Microservices should not be exposed to the open internet directly...they are usually protected by a firewall.
    Instead, all trafic goes through the load balancer. Which means that if up until now we made a request to
    the Customers microservice directly, http://localhost:8080/api/v1/customers, now we will go through
    the load balancer by using http://localhost:8083/api/v1/customers

13. We will use a message broker, Rabbit MQ, in order to handle the sending of notification. Right now, as the code is
    if for some reason, notification microservice takes 10s to process a request, then this will be a very bad
    user experience for the user. Since a notification like getting an email/SMS does not have to be instantaneous,
    the communication with the notification microservice will be done with a message broker....in this case
    Rabbit MQ.

14. When defining the Rabbit MQ, we specify 2 lines of ports, because some are for the microservices to connect to,
    while the second is for management port, so that you can use the management console.
              - "5672:5672"
              - "15672:15672"

15. For RabbitMQ UI console visit http://localhost:15672/. username and pass are guest/guest

16.  <artifactId>spring-boot-starter-amqp</artifactId>
        amqp comes from -> advanced message queue protocol

17. RabbitTemplate allows us to send messages
    SimpleRabbitListenerContainerFactory    allows us to receive messages from the queue

18. http://localhost:15672/ after all is setup, and you run the Eureka server and the Notification
    microservice (having a commandLineRunner in the application class that sends a message), if you
    go to Queues, and then click on Get Messages through the UI, you should be able to see the payload
    sent from the commandLineRunner

19. You can run the microservices from terminal by using the command (run this after you ran mvn package command)
    java -jar name_of_jar.jar

20. We will use Jib to create the docker images of our app
    https://github.com/GoogleContainerTools/jib

    In main pom we defined property that is used to create the image name. The first part
    "teshte" MUST be your docker hub username !!!
        <!-- this is used by Jib maven plugin to set the image version -->
        <image>teshte/${project.artifactId}:${project.version}</image>

     <!-- below plugin is used to create docker images -->
            <plugin>
              <groupId>com.google.cloud.tools</groupId>
              <artifactId>jib-maven-plugin</artifactId>
              <version>3.4.0</version>
              <configuration>
                <from>
                    <!-- this is the so called based image -->
                  <image>eclipse-temurin:17</image>
                </from>
                <to>
                  <tags>
                    <tag>latest</tag>
                  </tags>
                </to>
              </configuration>
            </plugin>


    Together with the definitions like the one from below that are in the microservice modules
        <profiles>
                <profile>
                    <id>build-docker-image</id>
                    <build>
                        <plugins>
                            <plugin>
                                <groupId>com.google.cloud.tools</groupId>
                                <artifactId>jib-maven-plugin</artifactId>
                                <executions>
                                    <execution>
                                        <phase>package</phase>
                                        <!-- goal from below will push our image to docker registry -->
                                        <goals>
                                            <goal>build</goal>
                                        </goals>
                                    </execution>
                                </executions>
                            </plugin>
                        </plugins>
                    </build>
                </profile>
            </profiles>

21. So to create and publish the image of a microservice on docker hub, select the profile
    "build-docker-image" and then run the "package" phase...(since you are logged in to docker
    hub because of the instalation/setup that i did some time ago)
        in case you get errors because of login issues, look for "docker login" and
        "docker logout" commands..

    You can run the "package" phase on a microservice module, like api-gateway, customer,
    fraud,notification, eureka-server, which will build and publish just the image of
    that microservice to docker hub, or just run it on the main, parent project, in which
    case all microservices docker images will be built and pushed to docker hub.


TODO ramas la








































